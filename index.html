<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Wanted Minigame</title>
</head>
<body>

    <canvas id='canvas'></canvas>

    <script src='assets.js'></script>
    <script src='controller.js'></script>
    <script src='helpers.js'></script>
    <script src='loop.js'></script>

    <script src='level_generation.js'></script>
    <script>

var W = 256;
var SH = 192;
var H = SH*2;

var canvas = document.getElementById('canvas');
var ctx = canvas.getContext('2d');
var scale = 1; // 0|Math.round(window.outerWidth / W, window.outerHeight / H);
console.log('scale:', scale);
canvas.width = W*scale;
canvas.height = H*scale;

var loop = new Loop();
var controller = new Controller(canvas);

var assets = {};
var bundle = [
    ['mario', 'image', 'src/gfx/mario.png'],
    ['luigi', 'image', 'src/gfx/luigi.png'],
    ['wario', 'image', 'src/gfx/wario.png'],
    ['yoshi', 'image', 'src/gfx/yoshi.png'],

    ['wanted_bg', 'image', 'src/gfx/wanted_bg.png'],
    ['mario_big', 'image', 'src/gfx/mario_big.png'],
    ['luigi_big', 'image', 'src/gfx/luigi_big.png'],
    ['wario_big', 'image', 'src/gfx/wario_big.png'],
    ['yoshi_big', 'image', 'src/gfx/yoshi_big.png'],

    ['time', 'image', 'src/gfx/time.png'],
    ['level', 'image', 'src/gfx/level.png'],
    ['numbers', 'image', 'src/gfx/numbers.png']
];
Assets.loadAssetBundle(assets, bundle,
(i) => {
    Helpers.drawBg(ctx);
    Helpers.drawLoadingBar(ctx, i/bundle.length);
},
() => {
    console.log('done loading');
    Helpers.drawBg(ctx);
    Helpers.drawText(ctx, ['Done loading!']);
    start();
    controller.enableMouse();
},
(e) => {
    throw e;
});

const STATE_DRUMROLL = 1;
const STATE_MAINGAME = 2;
const STATE_TIMEUP = 3;
const STATE_CORRECT = 4;

const DRUM_ROLL_DURATION = 120;

const E_MARIO = 1;
const E_LUIGI = 2;
const E_WARIO = 3;
const E_YOSHI = 4;

const BRO_ASSETS = {};
BRO_ASSETS[E_MARIO] = {
    sprite: 'mario',
    bigsprite: 'mario_big'
};
BRO_ASSETS[E_LUIGI] = {
    sprite: 'luigi',
    bigsprite: 'luigi_big'
};
BRO_ASSETS[E_WARIO] = {
    sprite: 'wario',
    bigsprite: 'wario_big'
};
BRO_ASSETS[E_YOSHI] = {
    sprite: 'yoshi',
    bigsprite: 'yoshi_big'
};

var holdingclick = false;
var state = 0;
var tick = 0;
var level = 0;
var wantedbro = 0;
var wantedbroi = 0;
var spotlightr = 0;
var lightson = false;

var time = 0;
var timetick = 0;
function updateTime() {
    if (time > 0 && ++timetick === 60) {
        timetick = 0;
        time--;
        if (time === 0) {
            timeUpEvent();
        }
    }
}

function drawNumber(x,y, n, numbersize=16, orientation=0) {
    var number = String(n);
    var numberssprite = assets['numbers'];

    ctx.imageSmoothingEnabled = false;
    for (var i = 0; i < number.length; i++) {
        var xx = (
            orientation === -1  ? x - numbersize * (number.length-1 - i) - numbersize/2 : // Right To Left
            orientation === 0   ? x + i * numbersize - (number.length-1) * numbersize/2 - numbersize/2 : // Center
            x + numbersize * i - numbersize/2 // Left To Right
        );
        var yy = y - numbersize/2;
        ctx.drawImage(
            numberssprite,
            parseInt(number[i]) * 16, 0,
            16,16,
            Math.round(xx * scale), Math.round(yy * scale),
            numbersize * scale, numbersize * scale
        );
    }
}
function drawGui() {
    if (state === STATE_DRUMROLL) {
        // Draw level display
        var levelsprite = assets['level'];
        var y = 168;
        ctx.drawImage(
            levelsprite,
            Math.round((W/2 - 16 * String(level+1).length - levelsprite.width/2) * scale),
            Math.round((y - levelsprite.height/2) * scale),
            levelsprite.width * scale, levelsprite.height * scale
        );

        drawNumber(W/2 + 40, y, level+1, 16, -1);
    }
    else {
        // Draw time display
        var timesprite = assets['time'];
        ctx.drawImage(
            timesprite,
            Math.round((W/2 - timesprite.width/2) * scale), Math.round(12 * scale),
            timesprite.width * scale, timesprite.height * scale
        );

        drawNumber(W/2, 22 + 16, time, 32, 0);
    }
}

function getRandomBroType() {
    var candidates = [E_MARIO,E_LUIGI,E_WARIO,E_YOSHI];
    return candidates[Helpers.randInt(0, candidates.length-1)];
}
function getRandomUnwantedBroType() {
    var candidates = [E_MARIO,E_LUIGI,E_WARIO,E_YOSHI];
    if (wantedbro !== 0)
        candidates.splice(wantedbro-1, 1);

    return candidates[Helpers.randInt(0, candidates.length-1)];
}
function selectNextWantedBro() {
    if (level === 9)
        wantedbro = E_LUIGI; // "On level 10, Luigi is always the character having to be found."
    else
        wantedbro = getRandomBroType();
    console.log('next wanted bro:', wantedbro);
}

var bros = [];
class Bro {
    constructor(x=0,y=0,z=0,bro=0,behavior=0) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.bro = bro;
        this.behavior = 1;

        this.vx = 0;
        this.vy = 0;
        this.wrap = false;
    }

    update() {
        switch (this.behavior) {
        case 1:
            this.x += this.vx;
            this.y += this.vy;
            if (this.wrap) {
                this.x = (this.x % W) + (this.x < 0) * W;
                this.y = (this.y % SH) + (this.y < 0) * SH;
            }
        }
    }

    mouseIsInside(x,y,offx=0,offy=0) {
        const size = 32;
        var left = this.x - size/2;
        var top = this.y - size/2;
        var right = this.x + size/2;
        var bottom = this.y + size/2;

        var inside = (x >= left && x <= right && y >= top && y <= bottom);

        if (!this.wrap)
            return inside;

        if (offx === 0 && left < 0)
            inside ||= this.mouseIsInside(x,y, W,offy);
        else if (offx === 0 && right > W)
            inside ||= this.mouseIsInside(x,y, -W,offy);

        if (offy === 0 && top < 0)
            inside ||= this.mouseIsInside(x,y, offx,SH);
        else if (offy === 0 && bottom > SH)
            inside ||= this.mouseIsInside(x,y, offx,-SH);

        return inside;
    }

    draw(offx=0, offy=0) {
        var sprite = assets[BRO_ASSETS[this.bro].sprite];
        var left = offx + this.x - sprite.width/2;
        var top = offy + this.y - sprite.height/2 + SH;

        ctx.drawImage(
            sprite,
            Math.round(left * scale), Math.round(top * scale),
            sprite.width * scale, sprite.height * scale
        );

        if (!this.wrap)
            return;

        // Wraparound
        if (offx === 0 && left < 0)
            this.draw(W, offy);
        else if (offx === 0 && left + sprite.width > W)
            this.draw(-W, offy);

        if (offy === 0 && top < SH)
            this.draw(offx, SH);
        else if (offy === 0 && top + sprite.height > H)
            this.draw(offx, -SH);
    }
}
function drawBros() {
    var sorted = [];
    for (var i = 0; i < bros.length; i++)
        sorted[i] = bros[i];

    sorted.sort((a, b) => {
        return a.z - b.z;
    })

    for (var i = 0; i < sorted.length; i++)
        sorted[i].draw();
}

function checkIfClickedBro() {
    var x = controller.x / scale;
    var y = controller.y / scale;

    if (x < 0 || x > W || y < SH || y > H)
        return;

    if (bros[wantedbroi].mouseIsInside(x,y - SH)) {
        console.log('yes :)');
        correctEvent();
        return;
    }

    for (var i = 0; i < bros.length; i++) {
        if (i === wantedbroi)
            continue;

        if (bros[i].mouseIsInside(x,y - SH)) {
            console.log('no :(');
            return;
        }
    }
}
function clearAllExceptWantedBro() {
    var bro = bros[wantedbroi];
    bros.length = 0;
    bros.push(bro);
    wantedbroi = 0;
}

function drawWantedBg() {
    var temp = document.createElement('canvas');
    var tempctx = temp.getContext('2d');
    temp.width = W*scale;
    temp.height = SH*scale;

    // Wanted background
    tempctx.drawImage(assets['wanted_bg'], 0,0, W*scale,SH*scale);

    // Big sprite
    var bigsprite = assets[BRO_ASSETS[wantedbro].bigsprite];
    var left = W/2 - bigsprite.width/2;
    var top = SH/2 - bigsprite.height/2 - 8;
    tempctx.drawImage(
        bigsprite,
        Math.round(left * scale), Math.round(top * scale),
        bigsprite.width * scale, bigsprite.height * scale
    );

    // Spotlight masks
    if (!lightson) {
        tempctx.globalCompositeOperation = 'destination-in';
        tempctx.fillStyle = '#ffffff';
        if (state === STATE_DRUMROLL) {
            var distscale = 0;
            const period = 40;
            if ((0|(tick / period)) & 1)
                distscale = (tick % period) / period;
            else
                distscale = (period - (tick % period)) / period;

            var dist = distscale * 200;

            tempctx.arc((W/2 + dist) * scale, SH/2 * scale, (spotlightr) * scale, Math.PI*2, 0);
            tempctx.arc((W/2 - dist) * scale, SH/2 * scale, (spotlightr) * scale, Math.PI*2, 0);
        }
        else {
            tempctx.arc((W/2) * scale, SH/2 * scale, (spotlightr) * scale, Math.PI*2, 0);
        }
    }

    tempctx.fill();
    tempctx.globalCompositeOperation = 'source-over';

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, W*scale, SH*scale);
    ctx.drawImage(temp, 0, 0, temp.width, temp.height);
}
function drawBg() {
    // Bottom background
    ctx.fillStyle = lightson ? '#FFE742' : '#000000';
    ctx.fillRect(0, SH*scale, W*scale, SH*scale);
}

function drumRollEvent() {
    tick = 0;
    lightson = false;
    spotlightr = 64;
    selectNextWantedBro();
    state = STATE_DRUMROLL;
}
function mainGameEvent() {
    tick = 0;
    generateLevel();
    state = STATE_MAINGAME;
}
function timeUpEvent() {
    tick = 0;
    state = STATE_TIMEUP;
}
function correctEvent() {
    tick = 0;
    state = STATE_CORRECT;
}
function update() {
    if (state === STATE_DRUMROLL) {
        tick++;

        if (tick === DRUM_ROLL_DURATION) {
            mainGameEvent();
        }

        drawBg();
        drawWantedBg();
        drawGui();
    }
    else if (state === STATE_MAINGAME) {
        updateTime();

        // Bros
        for (var i = 0; i < bros.length; i++) {
            bros[i].update();
        }

        // Clicking
        if (controller.clicking) {
            if (!holdingclick)
                checkIfClickedBro();
            holdingclick = true;
        }
        else {
            holdingclick = false;
        }

        drawBg();
        drawBros();
        drawWantedBg();
        drawGui();
    }
    else if (state === STATE_TIMEUP) {
        if (tick === 0) {
            clearAllExceptWantedBro();
        }
        tick++;

        if (tick >= 60)
            lightson = true;
        else
            spotlightr += 2;

        drawBg();
        drawBros();
        drawWantedBg();
        drawGui();
    }
    else if (state === STATE_CORRECT) {
        if (tick === 0) {
            clearAllExceptWantedBro();
        }
        tick++;

        if (tick >= 60)
            lightson = true;
        else
            spotlightr += 2;

        // Add time
        if (time < 50)
            for (var i = 0; i < 5; i++) {
                if (tick === 80 + i*4) {
                    time++;
                    break;
                }
            }

        // Next level
        if (tick === 240) {
            level++;
            drumRollEvent();

            if ((level % 5) !== 4)
                tick = DRUM_ROLL_DURATION - 30;
        }

        drawBg();
        drawBros();
        drawWantedBg();
        drawGui();
    }

    // drawBg();
    // drawBros();
    // drawWantedBg();
    // drawGui();
}

function start() {
    time = 10;
    drumRollEvent();

    loop.start();
    console.log('started');
}

loop.onUpdate = update;

    </script>

</body>
</html>